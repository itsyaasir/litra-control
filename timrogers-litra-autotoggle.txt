Directory structure:
â””â”€â”€ timrogers-litra-autotoggle/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ 99-litra.rules
    â”œâ”€â”€ Cargo.toml
    â”œâ”€â”€ LICENSE.md
    â”œâ”€â”€ .codespellignore
    â”œâ”€â”€ .pre-commit-config.yaml
    â”œâ”€â”€ src/
    â”‚   â””â”€â”€ main.rs
    â””â”€â”€ .github/
        â”œâ”€â”€ dependabot.yml
        â”œâ”€â”€ FUNDING.yml
        â””â”€â”€ workflows/
            â”œâ”€â”€ build-and-release.yml
            â””â”€â”€ pre-commit.yml

================================================
FILE: README.md
================================================
# `litra-autotoggle`

ðŸ’¡ Automatically turn your Logitech Litra device on when your webcam turns on, and off when your webcam turns off (macOS and Linux only)

---

## Supported devices

The following Logitech Litra devices, **connected via USB**, are supported:

- [Logitech Litra Glow](https://www.logitech.com/en-gb/products/lighting/litra-glow.946-000002.html)
- [Logitech Litra Beam](https://www.logitech.com/en-gb/products/lighting/litra-beam.946-000007.html)
- [Logitech Litra Beam LX](https://www.logitechg.com/en-gb/products/cameras-lighting/litra-beam-lx-led-light.946-000015.html)

## Installation

### macOS or Linux via [Homebrew](https://brew.sh/)

1. Install the latest version of `litra-autotoggle` by running `brew tap timrogers/tap && brew install litra-autotoggle`.
1. Run `litra-autotoggle --help` to check that everything is working.

### macOS or Linux via [Cargo](https://doc.rust-lang.org/cargo/), Rust's package manager

1. Install [Rust](https://www.rust-lang.org/tools/install) on your machine, if it isn't already installed.
1. Install the `litra-autotoggle` crate by running `cargo install litra-autotoggle`.
1. Run `litra-autotoggle --help` to check that everything is working and see the available commands.

### macOS or Linux via direct binary download

1. Download the [latest release](https://github.com/timrogers/litra-autotoggle/releases/latest) for your platform. macOS and Linux devices are supported.
1. Add the binary to `$PATH`, so you can execute it from your shell. For the best experience, call it `litra-autotoggle`.
1. Run `litra-autotoggle --help` to check that everything is working.

## Usage

### In the background, using Homebrew Services ([Homebrew](https://brew.sh/) installations only)

Run `brew services start timrogers/tap/litra-autotoggle`.

`litra-autotoggle` will run in the background, and your Litra will turn on when your webcam turns on, and off when your webcam turns off. If no Litra device is connected, the listener will keep on running, but will do nothing.

> [!NOTE]
> When starting the service for the first time on a macOS device, you will receive a notification warning you about software running in the background.

![macOS warning](https://github.com/user-attachments/assets/7abd6d99-0481-4684-8079-a6d80e0fcaea)

### From the command line

Just run `litra-autotoggle`. Your Litra will turn on when your webcam turns on, and off when your webcam turns off.

The following arguments are supported:

- `--serial-number` to point to a specific Litra device. You can get the serial number using the `litra devices` command in the [`litra`](https://github.com/timrogers/litra-rs) CLI.
- `--require-device` to enforce that a Litra device must be connected. By default, the listener will keep running even if no Litra device is found. With this set, the listener will exit whenever it looks for a Litra device and none is found.
- `--video-device` (Linux only) to watch a specific video device (e.g. `/dev/video0`). By default, all video devices will be watched.
- `--delay` to customize the delay (in milliseconds) between a webcam event being detected and toggling your Litra. When your webcam turns on or off, multiple events may be generated in quick succession. Setting a delay allows the program to wait for all events before taking action, avoiding flickering. Defaults to 1.5 seconds (1500 milliseconds).

## Configuring `udev` permissions (Linux only)

On most Linux operating systems, you will need to manually configure permissions using [`udev`](https://www.man7.org/linux/man-pages/man7/udev.7.html) to allow non-`root` users to access and manage Litra devices.

To allow all users that are part of the `video` group to access the Litra devices, copy the [`99-litra.rules`](99-litra.rules) file into `/etc/udev/rules.d`.

Next, reboot your computer or run the following commands as `root`:

    # udevadm control --reload-rules
    # udevadm trigger



================================================
FILE: 99-litra.rules
================================================
SUBSYSTEM=="hidraw", ATTRS{idVendor}=="046d", ATTRS{idProduct}=="c900", GROUP="video", MODE="0660"
SUBSYSTEM=="hidraw", ATTRS{idVendor}=="046d", ATTRS{idProduct}=="c901", GROUP="video", MODE="0660"
SUBSYSTEM=="hidraw", ATTRS{idVendor}=="046d", ATTRS{idProduct}=="b901", GROUP="video", MODE="0660"
SUBSYSTEM=="hidraw", ATTRS{idVendor}=="046d", ATTRS{idProduct}=="c903", GROUP="video", MODE="0660"



================================================
FILE: Cargo.toml
================================================
[package]
name = "litra-autotoggle"
version = "0.6.1"
edition = "2021"
authors = ["Tim Rogers <timrogers@github.com>"]
description = "Automatically turn your Logitech Litra device on when your webcam turns on, and off when your webcam turns off (macOS and Linux only)"
repository = "https://github.com/timrogers/litra-autotoggle"
license = "MIT"
readme = "README.md"
categories = ["hardware-support", "command-line-utilities"]
keywords = ["logitech", "litra", "glow", "beam", "light"]

# TODO: Remove this once we're on a newer tokio version that doesn't trip this up
# https://github.com/tokio-rs/tokio/pull/6874
[lints.clippy]
needless_return = "allow"

[[bin]]
name = "litra-autotoggle"
path = "src/main.rs"

[dependencies]
clap = { version = "4.5.32", features = ["derive"] }
litra = "2.2.0"
tokio = { version = "1.44.1", features = ["full"] }

[target.'cfg(target_os = "linux")'.dependencies]
inotify = { version = "0.11.0" }



================================================
FILE: LICENSE.md
================================================
The MIT License (MIT)

Copyright (c) 2024 Tim Rogers

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.



================================================
FILE: .codespellignore
================================================
crate



================================================
FILE: .pre-commit-config.yaml
================================================
default_language_version:
  python: python3
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: check-case-conflict
      - id: check-json
      - id: check-merge-conflict
      - id: check-symlinks
      - id: check-toml
      - id: check-xml
      - id: check-yaml
      - id: destroyed-symlinks
      - id: detect-private-key
      - id: end-of-file-fixer
      - id: fix-byte-order-marker
      - id: forbid-new-submodules
      - id: mixed-line-ending
      - id: trailing-whitespace
  - repo: https://github.com/codespell-project/codespell
    rev: v2.2.6
    hooks:
      - id: codespell
        args: [--ignore-words=.codespellignore]
  - repo: https://github.com/doublify/pre-commit-rust
    rev: v1.0
    hooks:
      - id: fmt
        args: [--all, --]
      - id: cargo-check
        args: [--locked, --workspace, --all-features, --all-targets]
      - id: clippy
        args:
          [
            --locked,
            --workspace,
            --all-features,
            --all-targets,
            --,
            -D,
            warnings,
          ]



================================================
FILE: src/main.rs
================================================
use clap::Parser;
#[cfg(target_os = "linux")]
use inotify::{EventMask, Inotify, WatchMask};
use litra::{Device, DeviceError, DeviceHandle, Litra};
use std::fmt;
use std::process::ExitCode;
#[cfg(target_os = "macos")]
use std::process::Stdio;
use std::sync::Arc;
#[cfg(target_os = "macos")]
use tokio::io::{AsyncBufReadExt, BufReader};
#[cfg(target_os = "macos")]
use tokio::process::Command;
use tokio::sync::Mutex;

/// Automatically turn your Logitech Litra device on when your webcam turns on, and off when your webcam turns off (macOS and Linux only).
#[derive(Debug, Parser)]
#[clap(name = "litra-autotoggle", version)]
struct Cli {
    #[clap(long, short, help = "The serial number of the Logitech Litra device")]
    serial_number: Option<String>,

    #[clap(
        long,
        short,
        action,
        help = "Exit with an error if no Litra device is found. By default, the program will run and listen for events even if no Litra device is found, but do nothing. With this option set, the program will exit whenever it looks for a Litra device and none is found."
    )]
    require_device: bool,

    #[cfg(target_os = "linux")]
    #[clap(
        long,
        short = 'd',
        help = "The path of the video device to monitor (e.g. `/dev/video0`) (Linux only). By default, all devices are monitored."
    )]
    video_device: Option<String>,

    #[clap(
        long,
        short = 't',
        default_value = "1500",
        help = "The delay in milliseconds between detecting a webcam event and toggling the Litra. When your webcam turns on or off, multiple events may be generated in quick succession. Setting a delay allows the program to wait for all events before taking action, avoiding flickering."
    )]
    delay: u64,

    #[clap(long, short, action, help = "Output detailed log messages")]
    verbose: bool,
}

fn check_serial_number_if_some(serial_number: Option<&str>) -> impl Fn(&Device) -> bool + '_ {
    move |device| {
        serial_number.as_ref().map_or(true, |expected| {
            device
                .device_info()
                .serial_number()
                .is_some_and(|actual| &actual == expected)
        })
    }
}

#[derive(Debug)]
enum CliError {
    DeviceError(DeviceError),
    IoError(std::io::Error),
    NoDevicesFound,
    DeviceNotFound(String),
}

impl fmt::Display for CliError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CliError::DeviceError(error) => error.fmt(f),
            CliError::IoError(error) => write!(f, "Input/output error: {}", error),
            CliError::NoDevicesFound => write!(f, "No Litra devices found"),
            CliError::DeviceNotFound(serial_number) => write!(
                f,
                "Litra device with serial number {} not found",
                serial_number
            ),
        }
    }
}

impl From<DeviceError> for CliError {
    fn from(error: DeviceError) -> Self {
        CliError::DeviceError(error)
    }
}

impl From<std::io::Error> for CliError {
    fn from(error: std::io::Error) -> Self {
        CliError::IoError(error)
    }
}

type CliResult = Result<(), CliError>;

fn get_first_supported_device(
    context: &mut Litra,
    serial_number: Option<&str>,
    require_device: bool,
) -> Result<Option<DeviceHandle>, CliError> {
    {
        context.refresh_connected_devices()?;
    }

    match context
        .get_connected_devices()
        .find(check_serial_number_if_some(serial_number))
    {
        Some(device_handle) => device_handle
            .open(context)
            .map(Some)
            .map_err(CliError::DeviceError),
        None => {
            if require_device {
                if let Some(serial_number) = serial_number {
                    Err(CliError::DeviceNotFound(serial_number.to_string()))
                } else {
                    Err(CliError::NoDevicesFound)
                }
            } else {
                Ok(None)
            }
        }
    }
}

fn turn_on_first_supported_device_and_log(
    context: &mut Litra,
    serial_number: Option<&str>,
    require_device: bool,
) -> Result<(), CliError> {
    if let Some(device_handle) = get_first_supported_device(context, serial_number, require_device)?
    {
        println!(
            "Turning on {} device (serial number: {})",
            device_handle.device_type(),
            get_serial_number_with_fallback(&device_handle)
        );

        device_handle.set_on(true)?;
    } else {
        print_device_not_found_log(serial_number);
    }

    Ok(())
}

fn turn_off_first_supported_device_and_log(
    context: &mut Litra,
    serial_number: Option<&str>,
    require_device: bool,
) -> Result<(), CliError> {
    if let Some(device_handle) = get_first_supported_device(context, serial_number, require_device)?
    {
        println!(
            "Turning off {} device (serial number: {})",
            device_handle.device_type(),
            get_serial_number_with_fallback(&device_handle)
        );

        device_handle.set_on(false)?;
    } else {
        print_device_not_found_log(serial_number);
    }

    Ok(())
}

fn print_device_not_found_log(serial_number: Option<&str>) {
    if serial_number.is_some() {
        println!(
            "Litra device with serial number {} not found",
            serial_number.unwrap()
        );
    } else {
        println!("No Litra devices found");
    }
}

fn get_serial_number_with_fallback(device_handle: &DeviceHandle) -> String {
    match device_handle.serial_number().unwrap() {
        Some(serial_number) => serial_number.to_string(),
        None => "-".to_string(),
    }
}

#[cfg(target_os = "macos")]
async fn handle_autotoggle_command(
    serial_number: Option<&str>,
    verbose: bool,
    require_device: bool,
    delay: u64,
) -> CliResult {
    // Wrap context in Arc<Mutex<>> to enable sharing across tasks
    let context = Arc::new(Mutex::new(Litra::new()?));

    // Use context inside an async block with locking
    {
        let mut context_lock = context.lock().await;
        if let Some(device_handle) =
            get_first_supported_device(&mut context_lock, serial_number, require_device)?
        {
            println!(
                "Found {} device (serial number: {})",
                device_handle.device_type(),
                get_serial_number_with_fallback(&device_handle)
            );
        } else {
            print_device_not_found_log(serial_number);
        }
    }

    println!("Starting `log` process to listen for video device events...");

    let mut child = Command::new("log")
        .arg("stream")
        .arg("--predicate")
        .arg("subsystem == \"com.apple.cmio\" AND (eventMessage CONTAINS \"AVCaptureSession_Tundra startRunning\" || eventMessage CONTAINS \"AVCaptureSession_Tundra stopRunning\")")
        .stdout(Stdio::piped())
        .spawn()?;

    let stdout = child
        .stdout
        .take()
        .expect("Failed to start `log` process to listen for video device events");
    let mut reader = BufReader::new(stdout).lines();

    println!("Listening for video device events...");

    // Add variables for throttling
    let mut pending_action: Option<tokio::task::JoinHandle<()>> = None;
    let desired_state = std::sync::Arc::new(tokio::sync::Mutex::new(None));

    while let Some(log_line) = reader
        .next_line()
        .await
        .expect("Failed to read log line from `log` process when listening for video device events")
    {
        if !log_line.starts_with("Filtering the log data") {
            if verbose {
                println!("{}", log_line);
            }

            // Update desired state based on the event
            if log_line.contains("AVCaptureSession_Tundra startRunning") {
                println!("Detected that a video device has been turned on.");

                let mut state = desired_state.lock().await;
                *state = Some(true);
            } else if log_line.contains("AVCaptureSession_Tundra stopRunning") {
                println!("Detected that a video device has been turned off.");

                let mut state = desired_state.lock().await;
                *state = Some(false);
            }

            // Cancel any pending action
            if let Some(handle) = pending_action.take() {
                handle.abort();
            }

            // Clone variables for the async task
            let desired_state_clone = desired_state.clone();
            let context_clone = context.clone();
            let serial_number_clone = serial_number.map(|s| s.to_string());

            // Start a new delayed action
            pending_action = Some(tokio::spawn(async move {
                tokio::time::sleep(tokio::time::Duration::from_millis(delay)).await;

                let state = {
                    let mut state = desired_state_clone.lock().await;
                    state.take()
                };

                if let Some(state) = state {
                    let mut context_lock = context_clone.lock().await;
                    if state {
                        println!("Attempting to turn on Litra device...");
                        let _ = turn_on_first_supported_device_and_log(
                            &mut context_lock,
                            serial_number_clone.as_deref(),
                            require_device,
                        );
                    } else {
                        println!("Attempting to turn off Litra device...");
                        let _ = turn_off_first_supported_device_and_log(
                            &mut context_lock,
                            serial_number_clone.as_deref(),
                            require_device,
                        );
                    }
                }
            }));
        }
    }

    let status = child.wait().await.expect(
        "Something went wrong with the `log` process when listening for video device events",
    );

    Err(CliError::IoError(std::io::Error::new(
        std::io::ErrorKind::Other,
        format!(
            "`log` process exited unexpectedly when listening for video device events - {}",
            status
        ),
    )))
}

#[cfg(target_os = "linux")]
async fn handle_autotoggle_command(
    serial_number: Option<&str>,
    _verbose: bool,
    require_device: bool,
    video_device: Option<&str>,
    delay: u64,
) -> CliResult {
    // Wrap context in Arc<Mutex<>> to enable sharing across tasks
    let context = Arc::new(Mutex::new(Litra::new()?));

    // Use context inside an async block with locking
    {
        let mut context_lock = context.lock().await;
        if let Some(device_handle) =
            get_first_supported_device(&mut context_lock, serial_number, require_device)?
        {
            println!(
                "Found {} device (serial number: {})",
                device_handle.device_type(),
                get_serial_number_with_fallback(&device_handle)
            );
        } else {
            print_device_not_found_log(serial_number);
        }
    }

    // Path to watch for video device events
    let watch_path = video_device.unwrap_or("/dev");

    // Extract video device name from path, or use "video" as default
    let video_file_prefix = video_device
        .and_then(|p| p.split('/').last())
        .unwrap_or("video");

    let mut inotify = Inotify::init()?;
    match inotify
        .watches()
        .add(watch_path, WatchMask::OPEN | WatchMask::CLOSE)
    {
        Ok(_) => println!("Watching {}", watch_path),
        Err(e) => eprintln!("Failed to watch {}: {}", watch_path, e),
    }

    // Add variables for throttling similar to macOS
    let mut pending_action: Option<tokio::task::JoinHandle<()>> = None;
    let desired_state = std::sync::Arc::new(tokio::sync::Mutex::new(None));

    let mut num_devices_open: usize = 0;
    loop {
        let start_num_devices_open = num_devices_open;

        // Read events that were added with `Watches::add` above.
        let mut buffer = [0; 1024];
        inotify
            .read_events_blocking(&mut buffer)?
            .filter_map(|event| match event.name.and_then(std::ffi::OsStr::to_str) {
                Some(name) if name.starts_with(video_file_prefix) => Some((name, event)),
                _ => None,
            })
            .for_each(|(name, event)| match event.mask {
                EventMask::OPEN => {
                    println!("Video device opened: {}", name);
                    num_devices_open = num_devices_open.saturating_add(1);
                }
                EventMask::CLOSE_WRITE | EventMask::CLOSE_NOWRITE => {
                    println!("Video device closed: {}", name);
                    num_devices_open = num_devices_open.saturating_sub(1);
                }
                _ => (),
            });

        // Since we're watching for events in `/dev`, we need to skip if the delta is 0
        // because it means there was no change in the number of video devices.
        if start_num_devices_open == num_devices_open {
            continue;
        }

        if num_devices_open == 0 {
            println!("Detected that a video device has been turned off.");

            let mut state = desired_state.lock().await;
            *state = Some(false);
        } else {
            println!("Detected that a video device has been turned on.");

            let mut state = desired_state.lock().await;
            *state = Some(true);
        };

        // Cancel any pending action
        if let Some(handle) = pending_action.take() {
            handle.abort();
        }

        // Clone variables for the async task
        let desired_state_clone = desired_state.clone();
        let context_clone = context.clone();
        let serial_number_clone = serial_number.map(|s| s.to_string());

        // Start a new delayed action
        pending_action = Some(tokio::spawn(async move {
            tokio::time::sleep(tokio::time::Duration::from_millis(delay)).await;

            let state = {
                let mut state = desired_state_clone.lock().await;
                state.take()
            };

            if let Some(state) = state {
                let mut context_lock = context_clone.lock().await;
                if state {
                    println!("Attempting to turn on Litra device...");
                    let _ = turn_on_first_supported_device_and_log(
                        &mut context_lock,
                        serial_number_clone.as_deref(),
                        require_device,
                    );
                } else {
                    println!("Attempting to turn off Litra device...");
                    let _ = turn_off_first_supported_device_and_log(
                        &mut context_lock,
                        serial_number_clone.as_deref(),
                        require_device,
                    );
                }
            }
        }));
    }
}

#[cfg(target_os = "macos")]
#[tokio::main]
async fn main() -> ExitCode {
    let args = Cli::parse();

    let result = handle_autotoggle_command(
        args.serial_number.as_deref(),
        args.verbose,
        args.require_device,
        args.delay,
    )
    .await;

    if let Err(error) = result {
        eprintln!("{}", error);
        ExitCode::FAILURE
    } else {
        ExitCode::SUCCESS
    }
}

#[cfg(target_os = "linux")]
#[tokio::main]
async fn main() -> ExitCode {
    let args = Cli::parse();

    let result = handle_autotoggle_command(
        args.serial_number.as_deref(),
        args.verbose,
        args.require_device,
        args.video_device.as_deref(),
        args.delay,
    );

    if let Err(error) = result.await {
        eprintln!("{}", error);
        ExitCode::FAILURE
    } else {
        ExitCode::SUCCESS
    }
}



================================================
FILE: .github/dependabot.yml
================================================
version: 2
updates:
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"
  - package-ecosystem: "cargo"
    directory: "/"
    schedule:
      interval: "weekly"



================================================
FILE: .github/FUNDING.yml
================================================
github: timrogers



================================================
FILE: .github/workflows/build-and-release.yml
================================================
name: Build, test and release

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main
    tags: "*"

jobs:
  build:
    name: Build and test
    strategy:
      fail-fast: false
      matrix:
        job:
          - {
              target: x86_64-unknown-linux-gnu,
              binary_name: linux-amd64,
              runs_on: ubuntu-latest,
            }
          - {
              target: aarch64-unknown-linux-gnu,
              binary_name: linux-aarch64,
              runs_on: self-hosted,
            }
          - {
              target: x86_64-apple-darwin,
              binary_name: darwin-amd64,
              runs_on: macos-latest,
            }
          - {
              target: aarch64-apple-darwin,
              binary_name: darwin-aarch64,
              runs_on: macos-latest,
            }
    runs-on: ${{ matrix.job.runs_on }}
    steps:
      - name: Install rustup (self-hosted runners only)
        run: curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
        if: matrix.job.runs_on == 'self-hosted'
      - name: Add $HOME/.cargo/bin to PATH (self-hosted runners only)
        run: echo "$HOME/.cargo/bin" >> $GITHUB_PATH
        if: matrix.job.runs_on == 'self-hosted'
      - name: Install libudev-dev
        run: sudo apt-get update && sudo apt-get install -y libudev-dev
        if: runner.os == 'Linux'
      - uses: actions/checkout@v4
      - name: Use Rust 1.83.0 with target ${{ matrix.job.target }}
        run: rustup override set 1.83.0-${{ matrix.job.target }}
      - uses: Swatinem/rust-cache@v2
      - name: Build in release mode
        run: cargo build --release --target=${{ matrix.job.target }}
      - name: Sanitise Git ref for use in filenames
        id: sanitise_ref
        run: echo "::set-output name=value::$(echo "${{ github.ref_name }}" | tr '/' '_')"
      - name: Rename Unix binary to use structured filename
        run: |
          rm target/${{ matrix.job.target }}/release/litra-autotoggle.d
          cp target/${{ matrix.job.target }}/release/litra-autotoggle* litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_${{ matrix.job.binary_name }}
      - name: Write Apple signing key to a file (macOS only)
        env:
          APPLE_SIGNING_KEY_P12: ${{ secrets.APPLE_SIGNING_KEY_P12 }}
        run: echo "$APPLE_SIGNING_KEY_P12" | base64 -d -o key.p12
        if: runner.os == 'macOS'
      - name: Write App Store Connect API key to a file (macOS only)
        env:
          APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}
        run: echo "$APP_STORE_CONNECT_API_KEY" > app_store_connect_api_key.json
        if: runner.os == 'macOS'
      - name: Sign macOS binary (macOS only)
        uses: indygreg/apple-code-sign-action@v1
        with:
          input_path: litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_${{ matrix.job.binary_name }}
          p12_file: key.p12
          p12_password: ${{ secrets.APPLE_SIGNING_KEY_PASSWORD }}
          sign: true
          sign_args: "--code-signature-flags=runtime"
        if: runner.os == 'macOS'
      - name: Upload binary as artifact
        uses: actions/upload-artifact@v4
        with:
          path: litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_${{ matrix.job.binary_name }}
          name: litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_${{ matrix.job.binary_name }}
      - name: Archive macOS binary for notarisation (macOS only)
        run: zip litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_${{ matrix.job.binary_name }}.zip litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_${{ matrix.job.binary_name }}
        if: runner.os == 'macOS'
      - name: Notarise signed macOS binary (macOS only)
        uses: indygreg/apple-code-sign-action@v1
        with:
          input_path: litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_${{ matrix.job.binary_name }}.zip
          sign: false
          notarize: true
          app_store_connect_api_key_json_file: app_store_connect_api_key.json
        if: runner.os == 'macOS'
  create_and_sign_macos_universal_binary:
    name: Create and sign macOS universal binary (macOS only)
    runs-on: macos-latest
    needs: build
    steps:
      - name: Sanitise Git ref for use in filenames
        id: sanitise_ref
        run: echo "::set-output name=value::$(echo "${{ github.ref_name }}" | tr '/' '_')"
      - name: Download macOS amd64 binary
        uses: actions/download-artifact@v4
        with:
          name: litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_darwin-amd64
      - name: Download macOS arm64 binary
        uses: actions/download-artifact@v4
        with:
          name: litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_darwin-aarch64
      - name: Create universal macOS binary
        run: lipo -create -output litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_darwin-universal litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_darwin-amd64 litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_darwin-aarch64
      - name: Write Apple signing key to a file (macOS only)
        env:
          APPLE_SIGNING_KEY_P12: ${{ secrets.APPLE_SIGNING_KEY_P12 }}
        run: echo "$APPLE_SIGNING_KEY_P12" | base64 -d -o key.p12
      - name: Write App Store Connect API key to a file (macOS only)
        env:
          APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}
        run: echo "$APP_STORE_CONNECT_API_KEY" > app_store_connect_api_key.json
      - name: Sign macOS binary (macOS only)
        uses: indygreg/apple-code-sign-action@v1
        with:
          input_path: litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_darwin-universal
          p12_file: key.p12
          p12_password: ${{ secrets.APPLE_SIGNING_KEY_PASSWORD }}
          sign: true
          sign_args: "--code-signature-flags=runtime"
      - name: Upload binary as artifact
        uses: actions/upload-artifact@v4
        with:
          path: litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_darwin-universal
          name: litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_darwin-universal
      - name: Archive macOS binary for notarisation (macOS only)
        run: zip litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_darwin-universal.zip litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_darwin-universal
      - name: Notarise signed macOS binary (macOS only)
        uses: indygreg/apple-code-sign-action@v1
        with:
          input_path: litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_darwin-universal.zip
          sign: false
          notarize: true
          app_store_connect_api_key_json_file: app_store_connect_api_key.json

  cargo_publish_dry_run:
    name: Publish with Cargo in dry-run mode
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      - name: Install libudev-dev
        run: sudo apt-get update && sudo apt-get install -y libudev-dev
      - name: Use Rust 1.83.0
        run: rustup override set 1.83.0
      - uses: Swatinem/rust-cache@v2
      - name: Install cargo-edit
        run: cargo install cargo-edit
      - name: Set the version to a dummy version to allow publishing
        run: cargo set-version 9.9.9
      - name: Publish to Crates.io
        run: cargo publish --dry-run --allow-dirty
  create_github_release:
    name: Create release with binary assets
    runs-on: ubuntu-latest
    needs:
      - build
      - create_and_sign_macos_universal_binary
    if: startsWith(github.event.ref, 'refs/tags/v')
    steps:
      - name: Sanitise Git ref for use in filenames
        id: sanitise_ref
        run: echo "::set-output name=value::$(echo "${{ github.ref_name }}" | tr '/' '_')"
      - uses: actions/download-artifact@v4
        with:
          name: litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_linux-amd64
      - uses: actions/download-artifact@v4
        with:
          name: litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_linux-aarch64
      - uses: actions/download-artifact@v4
        with:
          name: litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_darwin-amd64
      - uses: actions/download-artifact@v4
        with:
          name: litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_darwin-aarch64
      - uses: actions/download-artifact@v4
        with:
          name: litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_darwin-universal
      - name: Create release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_darwin-amd64
            litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_darwin-aarch64
            litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_linux-amd64
            litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_linux-aarch64
            litra-autotoggle_${{ steps.sanitise_ref.outputs.value }}_darwin-universal
  cargo_publish:
    name: Publish with Cargo to Crates.io
    runs-on: ubuntu-latest
    needs:
      - create_github_release
      - cargo_publish_dry_run
    if: startsWith(github.event.ref, 'refs/tags/v')
    steps:
      - uses: actions/checkout@v4
      - name: Install libudev-dev
        run: sudo apt-get update && sudo apt-get install -y libudev-dev
      - name: Use Rust 1.83.0
        run: rustup override set 1.83.0
      - uses: Swatinem/rust-cache@v2
      - name: Publish to Crates.io
        run: cargo publish --token ${{ secrets.CRATES_IO_API_TOKEN }}



================================================
FILE: .github/workflows/pre-commit.yml
================================================
name: pre-commit

on:
  push:
  pull_request:

jobs:
  pre-commit:
    runs-on: ubuntu-latest
    steps:
      - name: Install libudev-dev
        run: sudo apt-get update && sudo apt-get install libudev-dev

      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Set up Python
        uses: actions/setup-python@v5

      - name: Use Rust 1.83.0
        run: rustup override set 1.83.0

      - run: rustup component add clippy rustfmt

      - uses: Swatinem/rust-cache@v2

      - name: Detect code style issues
        uses: pre-commit/action@v3.0.1
        env:
          SKIP: no-commit-to-branch

      - name: Generate patch file
        if: failure()
        run: |
          git diff-index -p HEAD > "${PATCH_FILE}"
          [ -s "${PATCH_FILE}" ] && echo "UPLOAD_PATCH_FILE=${PATCH_FILE}" >> "${GITHUB_ENV}"
        env:
          PATCH_FILE: pre-commit.patch

      - name: Upload patch artifact
        if: failure() && env.UPLOAD_PATCH_FILE != null
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.UPLOAD_PATCH_FILE }}
          path: ${{ env.UPLOAD_PATCH_FILE }}


